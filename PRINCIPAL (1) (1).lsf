clear;

switchtolayout;                                       #inicio del diseño de la guia

###################################### PARAMETROS DE ENTRADA############################################### 

Alt_SiO2=1;                                           #Altura del SiO2
Anc_SiO2=10;                                           #Ancho del SiO2
Alt_Si=Alt_SiO2;                                      #Altura del Si                       				 
Anc_Si=Anc_SiO2;                                       #Ancho del Si

gap = 0.3;                                        
resol_FDE = 100;
sale_FDE=1;
cent_FDE_y= 0;                                           #Medida entre el borde del nucleo y la malla FDE 

Alt_ini=0.46667; Alt_fin=0.46667; num_puntos_Alt=1;           #Altura inicial y final del Si3N4 y numero de alturas
Anc_ini=0.5; Anc_fin=0.5; num_puntos_Anc=1;           #Ancho inicial y final del Si3N4  y numero de anchos
lamb_ini= 0.753; lamb_fin= 0.753; num_puntos_lamb=1;      #Longitud de onda inicial y final y numero de longitudes de onda

Alt_Si3N4=linspace(Alt_ini,Alt_fin,num_puntos_Alt);   #Vector  de alturas del Si3N4
Anc_Si3N4=linspace(Anc_ini,Anc_fin,num_puntos_Anc);   #Vector de anchos del Si3N4
lamb=linspace(lamb_ini,lamb_fin,num_puntos_lamb);     #Vector de longitudes de onda

#################### PARAMETROS PARA BUSCAR EN UN RANGO DE INDICES O CERCA DE UN INDICE ######################################  
near_n = 1;                                             #poner "0" para buscar en el rango min_n, max_n y "1" para buscar alrededor de n_near
n_near = 2.01;                                         #indice alrededor del cual se calculan los modos (solo sirve cuando se activa el "near")
min_n= 1.4;                                           #indice inferior del rango en el que se buscan los modos (solo sirve cuando se activa "in range")
max_n =2.01;                                           #indice superior del rango en el que se buscan los modos (solo sirve cuando se activa "in range")

###################################### HASTA AQUÍ PARAMETROS DE ENTRADA ####################################

if (near_n == 1){                                     #Con estas lineas se activa la busqueda alrededor del indice n_near siempre que near_n=1
    setanalysis("search", "near n");    
    setanalysis("n",n_near);
    setanalysis("use max index",0);
}

if (near_n == 0){                                     #Con estas lineas se activa la busqueda en un rango de indices siempre que near_n=0
    setanalysis("search", "in range");    
    setanalysis("n1",max_n);
    setanalysis("n2",min_n);
}

####################### DEFINIR NÚMERO DE CORRIDA PARA LOS ARCHIVOS #################################
run_number = 10000; 
str_out = "resultados_" + num2str(run_number) + ".csv";

#################### CREACION DE ARCHIVO CSV ######################################  
# Escribir encabezados (agrego Aeff al final)
header = "Altura (um),Ancho (um),Longitud de onda (um),Indice efectivo,Area efectiva (um^2),Overlap";   ### NUEVO: agregué Overlap ###
write(str_out, header);

###################################### BUCLES PRINCIPALES ######################################
for(kk=1:num_puntos_Alt) {                             
for(ii=1:num_puntos_Anc) {                             
for(nn=1:num_puntos_lamb) {                            

    setanalysis("wavelength", lamb(nn)*1e-6);          

    Geometriafinal;
    Mallasfinal;

    nmodes = findmodes;
    
                                    
    # Inicializar variables con valores por defecto (cero)
    neff_modo1 = 0;
    Aeff_modo1 = 0;
    overlap_val = 0;                                   ### NUEVO ###
    modo_encontrado = 0;
    
    if (nmodes == 0) {
        print("No se encontró ningún modo para esta geometría.");
        # No usar continue, en su lugar guardar los valores cero
    } else {
        ########### NUEVO: BÚSQUEDA DEL MODO FUNDAMENTAL POR OVERLAP ###########
        max_overlap = 0;
        mejor_modo = 1;
        
        # Calcular overlap para todos los modos encontrados
        for (i = 1:nmodes) {
            # Calcular overlap entre el modo de referencia y el modo actual
            overlap_result = overlap("Modo_ref_te_fundamental", "mode" + num2str(i));
            overlap_actual = overlap_result(1);  # Tomamos solo el mode overlap (primer valor)
            
            # Buscar el modo con mayor overlap
            if (overlap_actual > max_overlap) {
                max_overlap = overlap_actual;
                mejor_modo = i;
            }
        }
     
        
        # Seleccionar el modo con mayor overlap
        selectmode("mode" + num2str(mejor_modo)); 
        neff_modo1 = real(getdata("mode" + num2str(mejor_modo),"neff"));        
        Aeff_modo1 = getdata("mode" + num2str(mejor_modo),"mode effective area");
        overlap_val = max_overlap;                     ### NUEVO ###
        modo_encontrado = 1;
        
        print("Mejor modo: mode" + num2str(mejor_modo) + " con overlap = " + num2str(max_overlap));
    }

   
    # Crear fila en formato CSV (agregué overlap_val)
    fila = num2str(Alt_Si3N4(kk)) + "," + num2str(Anc_Si3N4(ii)) + "," + num2str(lamb(nn)) + "," + num2str(neff_modo1) + "," + num2str(Aeff_modo1) + "," + num2str(overlap_val);

    # Guardar en archivo
    write(str_out, fila);

    if (modo_encontrado == 1) {
        print("Altura = " + num2str(Alt_Si3N4(kk)) + ", Ancho = " + num2str(Anc_Si3N4(ii)) + ", Lambda = " + num2str(lamb(nn)) + ", neff = " + num2str(neff_modo1) + ", Aeff = " + num2str(Aeff_modo1) + ", Overlap = " + num2str(overlap_val));
        print("Cambio de Iteración:");
    } else {
        print("Altura = " + num2str(Alt_Si3N4(kk)) + ", Ancho = " + num2str(Anc_Si3N4(ii)) + ", Lambda = " + num2str(lamb(nn)) + ", neff = 0, Aeff = 0, Overlap = 0 (NO SE ENCONTRÓ MODO)");
    }

}   
}   
}